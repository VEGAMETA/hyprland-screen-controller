[main.hpp]
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <format>
#include <fstream>
#include <map>
#include <ostream>
#include <sstream>
#include <string>
#include <unistd.h>
#include <vector>

using namespace std;

inline string HOME(getenv("HOME"));
inline string SHADER_PATH = HOME + "/.config/hypr/screen_controller_shader.frag";
inline string CONFIG_PATH = HOME + "/.config/hypr/screen_controller_shader.conf";

inline void ltrim(string &s) {
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
                return !std::isspace(ch);
            }));
}

inline void rtrim(string &s) {
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
                return !isspace(ch);
            }).base(),
            s.end());
}

inline void trim(string &s) {
    rtrim(s);
    ltrim(s);
}

inline void toLower(string my_string) {
    std::transform(my_string.begin(), my_string.end(), my_string.begin(),
                   [](unsigned char c) { return tolower(c); });
}

inline void toUpper(string my_string) {
    std::transform(my_string.begin(), my_string.end(), my_string.begin(),
                   [](unsigned char c) { return toupper(c); });
}

inline bool fileExists(string path) {
    return filesystem::exists(path) && filesystem::is_regular_file(path);
}

inline string my_replace(string str, string from, string to) {
    size_t start_pos = str.find(from);
    if (start_pos == std::string::npos)
        return "";
    return str.replace(start_pos, from.length(), to);
}

inline vector<string> split_string(string str,
                                   const string &delimiter) {
    vector<string> strings;

    string::size_type pos = 0;
    string::size_type prev = 0;
    while ((pos = str.find(delimiter, prev)) != string::npos) {
        strings.push_back(str.substr(prev, pos - prev));
        prev = pos + delimiter.size();
    }

    // To get the last substring (or only, if delimiter is not found)
    strings.push_back(str.substr(prev));

    return strings;
}

void print_args(map<string, double> args);
string set_args(string base_shader, map<string, double> args);

// 1 - 5 numbers of fact
inline string fmtFract(double value) {
    value = round(value * 10e5) / 10e5f;
    string s = format("{:.5f}", value);
    size_t dot = s.find('.');
    for (size_t i = s.size() - 1; i > s.find_last_not_of('0') && i > (dot + 1); i--)
        s.erase(i);
    return s;
}

inline map<string, double> DEFAULT_ARGS{
    {"--temperature", 6500},
    {"--brightness", 1.0},
    {"--contrast", 1.0},
    {"--gamma", 1.0},
    {"--saturation", 1.0},
    {"--hue", 0.0},
    {"--red", 1.0},
    {"--green", 1.0},
    {"--blue", 1.0},
};

inline string BASE_CONFIG = R"(temperature = TEMPERATURE
brightness = BRIGHTNESS
contrast = CONTRAST
hue = HUE
saturation = SATURATION
gamma = GAMMA
red = RED
green = GREEN
blue = BLUE
)";

inline string BASE_SHADER = R"(#version 330 core

precision mediump float;
varying vec2 v_texcoord;
uniform sampler2D tex;

vec3 new_color = vec3(RED, GREEN, BLUE);

vec3 temperatureToRGB(float temp) {
    temp = clamp(temp, 1000.0, 40000.0) / 100.0;
    vec3 color;
    
    if (temp <= 66.0) color.r = 1.0;
    else color.r = 1.292936 * pow(temp - 60.0, -0.1332047);
    
    if (temp <= 66.0) color.g = 0.39008157 * log(temp) - 0.63184144;
    else color.g = 1.129890 * pow(temp - 60.0, -0.0755148);
    
    if (temp >= 66.0) color.b = 1.0;
    else if (temp <= 19.0) color.b = 0.0;
    else color.b = 0.543206789 * log(temp - 10.0) - 1.19625408;
    
    return clamp(color, 0.0, 1.0);
}

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    vec4 pixColor = texture2D(tex, v_texcoord);
    vec3 color = pixColor.rgb;
    color *= temperatureToRGB(TEMPERATURE);
    color *= BRIGHTNESS;
    color = mix(vec3(dot(vec3(1.0/3.0), color)), color, CONTRAST);
    vec3 hsv = rgb2hsv(color);
    hsv.x = fract(hsv.x + HUE);
    hsv.y *= SATURATION;
    color = hsv2rgb(hsv);
    color = pow(color, vec3(1.0 / GAMMA));
    color *= new_color;
    color = clamp(color, 0.0, 1.0);
    gl_FragColor = vec4(color, pixColor.a);
}
)";

inline string HELP = R"(
Arguments & range
--temperatue 6700.0   ~ 1000-40000
--brightness 1.0      ~ 0.1-2.0
--contrast 0.9        ~ 0.1-2.0
--saturation 1.15     ~ 0.1-2.0
--gamma 1.15          ~ 0.1-3.0
--hue 0.007           ~ -1.0-+1.0
--red 1.0             ~ 1.0-2.0
--green 1.0           ~ 1.0-2.0
--blue 1.0            ~ 1.0-2.0
)";


[main.cpp]
#include "main.hpp"

void save_config(map<string, double> args) {
    string config(BASE_CONFIG);
    config = set_args(config, args);
    ofstream file(CONFIG_PATH);
    if (!file.is_open())
        throw runtime_error("Failed to open file: " + CONFIG_PATH);
    file << config.c_str();
}

map<string, double> get_config() {
    map<string, double> args(DEFAULT_ARGS);
    string line;
    ifstream file(CONFIG_PATH);
    if (!file.is_open())
        throw runtime_error("Failed to open file: " + CONFIG_PATH);
    ostringstream l;
    l << file.rdbuf();
    for (auto line : split_string(l.str(), "\n")) {
        vector<string> kv = split_string(line, "=");
        if (kv.size() != 2)
            continue;
        trim(kv[0]);
        args["--" + kv[0]] = atof(kv[1].c_str());
    }
    return args;
}

map<string, double> get_args() {
    return fileExists(CONFIG_PATH) ? get_config() : DEFAULT_ARGS;
}

void print_args(map<string, double> args) {
    for (auto p : args) {
        string arg = my_replace(p.first, "--", "");
        if (arg == "")
            continue;
        printf("%s=%s\n", arg.c_str(), fmtFract(p.second).c_str());
    }
}

string set_args(string base_shader, map<string, double> args) {
    string new_shader(base_shader);
    new_shader = my_replace(new_shader, "TEMPERATURE", fmtFract(args["--temperature"]));
    new_shader = my_replace(new_shader, "BRIGHTNESS", fmtFract(args["--brightness"]));
    new_shader = my_replace(new_shader, "CONTRAST", fmtFract(args["--contrast"]));
    new_shader = my_replace(new_shader, "HUE", fmtFract(args["--hue"]));
    new_shader = my_replace(new_shader, "SATURATION", fmtFract(args["--saturation"]));
    new_shader = my_replace(new_shader, "GAMMA", fmtFract(args["--gamma"]));
    new_shader = my_replace(new_shader, "RED", fmtFract(args["--red"]));
    new_shader = my_replace(new_shader, "GREEN", fmtFract(args["--green"]));
    new_shader = my_replace(new_shader, "BLUE", fmtFract(args["--blue"]));
    return new_shader;
}

void save_shader(string new_shader) {
    ofstream file(SHADER_PATH);
    if (!file.is_open())
        throw runtime_error("Failed to open file: " + SHADER_PATH);
    file << new_shader.c_str();
}

void reload_hyprland() { system("hyprctl reload"); }

int main(int argc, char **argv) {
    map<string, double> args = get_args();

    if (argc == 1) {
        print_args(args);
        save_shader(set_args(BASE_SHADER, args));
        reload_hyprland();
        return 0;
    }

    if (argc == 2 && (strcmp(argv[1], "--help") || strcmp(argv[1], "help") ||
                      strcmp(argv[1], "-h")))
        return puts(HELP.c_str());

    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == 45 && i + 1 < argc) {
            args[argv[i]] = atof(argv[i + 1]);
            if (args[argv[i]] < 0.1 && (strcmp("--brightness", argv[i]) == 0 || strcmp("--gamma", argv[i]) == 0))
                args[argv[i]] = 0.1;
            i++;
        }
    };

    save_shader(set_args(BASE_SHADER, args));
    save_config(args);
    reload_hyprland();
    return 0;
}


[Makefile]
# Compiler
CXX := gcc

# Compiler flags
CXXFLAGS := -Os -s -DNDEBUG -ffunction-sections -fdata-sections -flto 
Ð¡XXFLAGS += -fno-rtti -fno-unwind-tables -fno-asynchronous-unwind-tables
CXXFLAGS += -Wl,--gc-sections -Wl,--strip-all -Wall -Wextra -std=c++23

# Linker flags (includes -lstdc++ which you might need)
LDFLAGS := -lstdc++ -lm -lpthread

# Source files (change this to match your source files)
SRCS := main.cpp

# Object files
OBJS := $(SRCS:.cpp=.o)

# Executable name
TARGET := hssc

# Default target
all: $(TARGET)

# Link the executable
$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) $^ -o $@ $(LDFLAGS)

# Compile source files to object files
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

install: all
	sudo cp $(TARGET) /usr/bin
	hssc

uninstall:
	sudo rm -f /usr/bin/$(TARGET)

clean:
	rm -f $(OBJS) $(TARGET)

.PHONY: all clean
